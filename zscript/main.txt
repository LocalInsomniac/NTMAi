class NTMAI : EventHandler {
	/* ====
	   MATH
	   ==== */
	
	static double Lerp(double a, double b, double f) {
		return a + f * (b - a);
	}
	
	static Vector3 Lerp3(Vector3 a, Vector3 b, double f) {
		return (a + (f * (b - a)));
	}
	
	/* ========
	   HANDLING
	   ======== */
	
	override void PlayerEntered(PlayerEvent e) {
		let pmo = players[e.playerNumber].mo;
		
		if (pmo) {
			pmo.A_TakeInventory("NTM_Bloody");
			pmo.A_TakeInventory("NTM_PistolShots");
			
			if (!pmo.CountInv("NTM_System_Actor")) {
				pmo.A_GiveInventory("NTM_System_Actor", 1);
			}
			
			/* GROSS HACK: Reset NTM_Player's values in here instead of
						   PostBeginPlay(), because they persist between level
						   changes and can mess up things when spawning! */
			if (pmo is "NTM_Player") {
				NTM_Player nmo = NTM_Player(pmo);
				
				nmo.fallState = 0;
				nmo.fallTics = 0;
				nmo.fallTics2 = 0;
				
				nmo.oldHealth = nmo.health;
				nmo.painTics = 0;
				
				if (sv_ntm_startTwitch) {
					// Emulate Duke3D twitching using spawn angle
					nmo.A_SetViewAngle(nmo.DeltaAngle(nmo.angle, 0));
				}
			}
		}
	}
	
	override void PlayerRespawned(PlayerEvent e) {
		let pmo = players[e.playerNumber].mo;
		
		if (pmo) {
			DoThingRevive(pmo);
		}
	}
	
	override void WorldThingSpawned(WorldEvent e) {
		let mo = e.thing;
		
		if (mo && mo.bIsMonster && !mo.CountInv("NTM_System_Actor")) {
			mo.A_GiveInventory("NTM_System_Actor", 1);
		}
	}
	
	override void WorldThingDied(WorldEvent e) {
		let mo = e.thing;
		
		if (mo.bIsMonster || mo is "PlayerPawn") {
			mo.bXFlip = Random(0, 1);
		}
	}
	
	override void WorldThingRevived(WorldEvent e) {
		DoThingRevive(e.thing);
	}
	
	void DoThingRevive(Actor mo) {
		if (mo.CountInv("NTM_System_Actor")) {
			let actorSystem = NTM_System_Actor(mo.FindInventory("NTM_System_Actor"));
			
			actorSystem.dead = false;
			actorSystem.gibbed = false;
			actorSystem.crushed = false;
		}
		
		mo.bXFlip = mo.default.bXFlip;
		
		if (!(mo is "PlayerPawn")) {
			mo.translation = mo.default.translation;
		}
	}
	
	override void CheckReplacement(ReplaceEvent e) {
		switch (e.replacee.GetClassName()) {
			case 'Zombieman':
				if (sv_ntm_r_zombieman) {
					e.replacement = "NTM_Zombieman";
				}
			break;
			
			case 'ShotgunGuy':
				if (sv_ntm_r_shotgunGuy) {
					e.replacement = "NTM_ShotgunGuy";
				}
			break;
			
			case 'ChaingunGuy':
				if (sv_ntm_r_heavyWeaponDude) {
					e.replacement = "NTM_ChaingunGuy";
				}
				
			break;
			
			case 'DoomImp':
				if (sv_ntm_r_imp) {
					e.replacement = "NTM_Imp";
				}
			break;
			
			case 'LostSoul':
				if (sv_ntm_r_lostSoul) {
					e.replacement = "NTM_LostSoul";
				}
			break;
			
			case 'Demon':
				if (sv_ntm_r_demon) {
					e.replacement = "NTM_Demon";
				}
			break;
			
			case 'Spectre':
				if (sv_ntm_r_spectre) {
					e.replacement = "NTM_Spectre";
				}
			break;
			
			case 'Cacodemon':
				if (sv_ntm_r_cacodemon) {
					e.replacement = "NTM_Cacodemon";
				}
			break;
			
			case 'HellKnight':
				if (sv_ntm_r_hellKnight) {
					e.replacement = "NTM_HellKnight";
				}
			break;
			
			case 'BaronOfHell':
				if (sv_ntm_r_baronOfHell) {
					e.replacement = "NTM_BaronOfHell";
				}
			break;
			
			case 'Arachnotron':
				if (sv_ntm_r_arachnotron) {
					e.replacement = "NTM_Arachnotron";
				}
			break;
			
			case 'PainElemental':
				if (sv_ntm_r_painElemental) {
					e.replacement = "NTM_PainElemental";
				}
			break;
			
			case 'Revenant':
				if (sv_ntm_r_revenant) {
					e.replacement = "NTM_Revenant";
				}
			break;
			
			case 'Fatso':
				if (sv_ntm_r_mancubus) {
					e.replacement = "NTM_Mancubus";
				}
			break;
			
			case 'Archvile':
				if (sv_ntm_r_archVile) {
					e.replacement = "NTM_ArchVile";
				}
			break;
			
			case 'Cyberdemon':
				if (sv_ntm_r_cyberdemon) {
					e.replacement = "NTM_Cyberdemon";
				}
			break;
			
			case 'SpiderMastermind':
				if (sv_ntm_r_spiderMastermind) {
					e.replacement = "NTM_SpiderMastermind";
				}
			break;
			
			case 'WolfensteinSS':
				if (sv_ntm_r_ss) {
					e.replacement = "NTM_German";
				}
			break;
			
			case 'RealGibs':
				e.replacement = "NTM_RealGibs";
			break;
		}
	}
	
	override void CheckReplacee(ReplacedEvent e) {
		switch (e.replacement.GetClassName()) {
			case 'NTM_Zombieman':
				e.replacee = "Zombieman";
			break;
			
			case 'NTM_ShotgunGuy':
				e.replacee = "ShotgunGuy";
			break;
			
			case 'NTM_ChaingunGuy':
				e.replacee = "ChaingunGuy";
			break;
			
			case 'NTM_DoomImp':
				e.replacee = "DoomImp";
			break;
			
			case 'NTM_Demon':
				e.replacee = "Demon";
			break;
			
			case 'NTM_Spectre':
				e.replacee = "Spectre";
			break;
			
			case 'NTM_LostSoul':
				e.replacee = "LostSoul";
			break;
			
			case 'NTM_Cacodemon':
				e.replacee = "Cacodemon";
			break;
			
			case 'NTM_HellKnight':
				e.replacee = "HellKnight";
			break;
			
			case 'NTM_BaronOfHell':
				e.replacee = "BaronOfHell";
			break;
			
			case 'NTM_Arachnotron':
				e.replacee = "Arachnotron";
			break;
			
			case 'NTM_PainElemental':
				e.replacee = "PainElemental";
			break;
			
			case 'NTM_Revenant':
				e.replacee = "Revenant";
			break;
			
			case 'NTM_Mancubus':
				e.replacee = "Fatso";
			break;
			
			case 'NTM_ArchVile':
				e.replacee = "ArchVile";
			break;
			
			case 'NTM_Cyberdemon':
				e.replacee = "Cyberdemon";
			break;
			
			case 'NTM_SpiderMastermind':
				e.replacee = "SpiderMastermind";
			break;
			
			case 'NTM_German':
				e.replacee = "WolfensteinSS";
			break;
			
			case 'NTM_RealGibs':
				e.replacee = "RealGibs";
			break;
		}
	}
}

// System Base
class NTM_System : Inventory {
	Default {
		Inventory.MaxAmount 1;
		FloatBobPhase 0;
		
		+Inventory.Undroppable
		+Inventory.Untossable
		+Inventory.AutoActivate
	}
	
	States {
		Use:
			TNT1 A 0;
			Fail;
		
		Pickup:
			TNT1 A 0 {
				return true;
			}
			
			Stop;
	}
}

// Actor System
class NTM_System_Actor : NTM_System {
	bool dead, gibbed, crushed, chopped, rKO;
	int fallTics, footprintState, footprintTics, footprintSide, deathLastFrame;
	float deathLastHeight;
	Actor gibDummy, bloodPool, footprintBloodPool;
	
	override void PostBeginPlay() {
		super.PostBeginPlay();
		footprintSide = -1;
		deathLastFrame = -1;
	}
	
	override void Tick() {
		// Monster/Player death effects
		if (owner.health <= 0) {
			// Blood: Jittering death animation
			if (sv_ntm_enemyMove == 1 && !owner.bBoss && !(owner is "PlayerPawn")) {
				int frame = owner.curState.frame;
				
				if (deathLastFrame != frame) {
					Vector2 spriteSize = TexMan.GetScaledSize(owner.curState.GetSpriteTexture(0));
					float spriteHeight = spriteSize.y;
					
					if (frame > 0 && owner.waterLevel == 0) {
						float jitter = Max(0, (deathLastHeight - spriteHeight) * 0.5);
						
						owner.SetOrigin(owner.pos + (0, 0, owner.scale.y * jitter), false);
						owner.ClearInterpolation();
					}
					
					deathLastFrame = frame;
					deathLastHeight = spriteHeight;
				}
			}
			
			if (!owner.bNoBlood) {
				// Duke Nukem 3D: Blood splatter on long falls
				if (owner.pos.z <= owner.floorZ || owner.bOnMObj) {
					if (fallTics > 18 && owner.waterLevel == 0) {
						for (int i; i < Random(3, 6); i++) {
							owner.A_SpawnItemEx("NTM_FlyingBlood", 0, 0, 0, Random(-8, 8), Random(-8, 8), Random(3, 8), 0, SXF_UseBloodColor);
						}
						
						owner.A_StartSound("NTM_System_Actor/pancake");
					}
					
					fallTics = 0;
				} else {
					if (!(owner is "PlayerChunk")) {
						++fallTics;
					}
				}
				
				if (!dead) {
					if (!gibbed) {
						// Common: Ludicrous gibs and taunting
						if (owner.health < owner.GetGibHealth()) {
							for (int i; i < Random(5, 8); i++) {
								if (i >= 0 && i <= 2) {
									owner.A_SpawnItemEx("NTM_FlyingGib"..(i + 1), 0, 0, 0, Random(-10, 10), Random(-10, 10), Random(8, 12), 0, SXF_UseBloodColor);
								}
								
								owner.A_SpawnItemEx("NTM_FlyingBlood", 0, 0, 0, Random(-8, 8), Random(-8, 8), Random(3, 8), 0, SXF_UseBloodColor);
							}
							
							let killer = owner.target;
							
							if (killer is "NTM_Player" && killer.health > 0 && !Random(0, 16)) {
								killer.A_StartSound("NTM_Player/taunt", Chan_Voice);
							}
							
							gibbed = true;
						}
					}
					
					dead = true;
				}
				
				// Duke Nukem 3D & Shadow Warrior: Blood pools
				if (!bloodPool && owner.health < (owner.GetGibHealth() * 0.666) && !(owner is "PlayerChunk") && owner.vel ~== (0, 0, 0) && owner.pos.z <= owner.floorZ) {
					bool result;
					Actor bloodP;
					
					[result, bloodP] = owner.A_SpawnItemEx("NTM_BloodPool", -1, flags: SXF_UseBloodColor);
					
					if (bloodP) {
						bloodPool = bloodP;
						bloodP.target = owner;
						bloodP.SetOrigin(owner.pos, false);
					}
				}
				
				// Duke Nukem 3D: Stretchy gibs under crushers
				if (!crushed && owner.pos.z <= owner.floorZ && owner.ceilingZ <= (owner.pos.z + owner.GetDeathHeight())) {
					if (owner.radius > 31) {
						owner.A_SpawnItemEx("NTM_BigGibs", flags: SXF_UseBloodColor);
					} else {
						if (owner.radius > 23) {
							owner.A_SpawnItemEx("NTM_MediumGibs", flags: SXF_UseBloodColor);
						} else {
							owner.A_SpawnItemEx("NTM_SmallGibs", flags: SXF_UseBloodColor);
						}
					}
					
					crushed = true;
				}
				
				// Common: Gibbable corpses
				bool isGibbable = (dead && !gibbed && !crushed && owner.curState.tics == -1 && !owner.bNoBlood && !owner.bBoss);
				
				if (gibDummy) {
					if (!isGibbable) {
						gibDummy.Destroy();
						gibDummy = null;
					}
				} else {
					if (isGibbable) {
						let mo = NTM_Dummy_Gib(Actor.Spawn("NTM_Dummy_Gib", owner.pos));
						
						if (mo) {
							gibDummy = mo;
							gibDummy.tracer = owner;
							gibDummy.health = -owner.GetGibHealth() * 0.25;
							gibDummy.A_SetSize(owner.radius, owner.height);
						}
					}
				}
				
				// Shadow Warrior: Gore effects on melee kill
				if (!chopped && owner.damageTypeReceived == "Chainsaw") {
					for (int i = 0; i < 2; ++i) {
						owner.A_SpawnItemEx("NTM_FlyingBlood", 8, 4, 28, FRandom(2, 5), FRandom(-5, -2), FRandom(2, 6), 0, SXF_UseBloodColor);
					}
					
					owner.A_StartSound("NTM_Chainsaw/slash", Chan_Body, ChanF_Overlap);
					owner.A_GiveToTarget("NTM_Bloody", 1);
					chopped = true;
				}
			}
			
			// Shadow Warrior: Knockback on powerful weapons
			if (!rKO && !owner.bBoss && (owner.damageTypeReceived == "Berserk" || owner.damageTypeReceived == "SuperShotgun")) {
				let killer = owner.target;
				
				if (killer) {
					double dist = owner.Distance3D(killer);
					
					if (dist > 0) {
						double force = (8 / Max(1, dist * 0.005)) * (100 / owner.mass);
						
						if (force > 1.25) {
							owner.A_FaceTarget();
							owner.A_ChangeVelocity(-force, 0, force * 0.8, CVF_Relative);
						}
					}
				}
				
				rKO = true;
			}
		} else {
			// Duke Nukem 3D & Shadow Warrior: Bloody Footprints
			if (owner is "PlayerPawn" && owner.pos.z <= owner.floorZ) {
				if (owner.vel.Length() > 0) {
					--footprintTics;
					++footprintState;
					
					if (footprintState >= 8) {
						if (footprintTics > 0 && footprintBloodPool) {
							bool result;
							Actor footprint;
							double ang = owner.angle;
							
							[result, footprint] = footprintBloodPool.A_SpawnItemEx("NTM_BloodyFootprint", angle: ang, flags: SXF_TransferTranslation | SXF_AbsoluteAngle | SXF_NoCheckPosition);
							
							if (footprint) {
								double footAngle = ang + (footprintSide * 90);
								
								footprint.SetOrigin((owner.pos.x + Cos(footAngle) * 5, owner.pos.y + Sin(footAngle) * 5, owner.pos.z), false);
							}
						}
						
						footprintState = 0;
						footprintSide *= -1;
					}
				} else {
					footprintSide = -1;
					footprintState = 0;
				}
			}
			
			// Reset all death mechanics
			deathLastFrame = -1;
			bloodPool = null;
			
			if (gibDummy) {
				gibDummy.Destroy();
				gibDummy = null;
			}
		}
		
		Super.Tick();
	}
}

// Gib Dummy
class NTM_Dummy_Gib : Actor {
	Default {
		+DontGib
		+NotOnAutomap
		+NoGravity
		+Vulnerable
		-Synchronized
	}
	
	States {
		Spawn:
			TNT1 A -1;
			Stop;
		
		Death:
			TNT1 A 0 {
				if (tracer) {
					tracer.A_StartSound("misc/gibbed");
					tracer.sprite = GetSpriteIndex("NMGI");
					tracer.frame = 7;
					tracer.scale = (0.666, 0.666);
					
					if (!(tracer is "PlayerPawn")) {
						tracer.translation = tracer.bloodTranslation;
					}
					
					tracer.health = tracer.GetGibHealth() - 1;
					
					for (int i; i < Random(5, 8); i++) {
						if (i >= 0 && i <= 2) {
							tracer.A_SpawnItemEx("NTM_FlyingGib"..(i + 1), 0, 0, 0, Random(-10, 10), Random(-10, 10), Random(8, 12), 0, SXF_UseBloodColor);
						}
						
						tracer.A_SpawnItemEx("NTM_FlyingBlood", 0, 0, 0, Random(-8, 8), Random(-8, 8), Random(3, 8), 0, SXF_UseBloodColor);
					}
					
					let actorSystem = NTM_System_Actor(tracer.FindInventory("NTM_System_Actor"));
					
					if (actorSystem) {
						actorSystem.gibbed = true;
					}
				}
			}
			
			Stop;
	}
	
	override void Tick() {
		Super.Tick();
		
		if (tracer) {
			SetOrigin(tracer.pos, false);
		} else {
			Destroy();
		}
	}
}